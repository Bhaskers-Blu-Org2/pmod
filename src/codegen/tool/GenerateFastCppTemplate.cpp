/***
* Copyright (C) Microsoft. All rights reserved.
* Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
*
* File:GenerateFastCppTemplate.cpp
****/
#include "GenerateFastCppTemplate.h"
#include "guidhelper.h"
#include "md5Util.h"

// Format template for FastModel Header File
// {0} = Model autogenerated includes eg:[modelInc].g.h
// {1} = Model adapters includes eg:[modelAdapterInc].g.h
// {2} = Model definitions include eg:[model].g.h
// {3} = Namespace
// {4} = FastModel templates/classes
static const wchar_t* _fastModelContainerHeader_Template =
L"\
#pragma once\n\
\n\
{0} \n\
#include \"{1}\" \n\
#include \"{2}\" \n\
\n\
#include <foundation/pv_util.h> \n\
#include <pmod/library/fast_template_library.h> \n\
#include <foundation/library/logger_macros.h> \n\
#include <foundation/library/async_operation_class_ptr.h> \n\
\n\
{3} \n\
\n\
\n\
{4} \n\
// Base Classes for inheritance \n\
{5} \n\
{6} \n\
\n\
";

static const wchar_t* _fastModelPrivateInterfaceCpp_Template =
L"\
#include \"{0}\" \n\
\n\
{1}\n\
\n\
";

// {0} = AdapterInc file include
// {1} = Model namespace
// {2} = Interface definition
static const wchar_t* _fastModelPrivateInterfaceHeader_Template =
L"\
 #pragma once\n\
 \n\
 #include \"{0}\" \n\
{1}\n\
\n\
// Private interface declarations\n\
\n\
{2}\n\
\n\
{3}\n\
\n\
";

static const wchar_t* _fastModelGetSetValueSwitchTemplate =
L"\t\tswitch (propertyId)\n\
\t\t{ \n\
{0}\
\t\t}\n";

// Format template for the FastModel containers
// {0} = TypeContainer Name eg: simple_model
// {1} = Container Base class
// {2} = PropertyGet case statements
// {3} = PropertySet case statements
static const wchar_t* _fastModelContainerClass_Template =
L"template <class T> \n\
class _Fast{0}Container : \n\
    public {1} \n\
{\n\
protected:\n\
    typedef {1} _BaseType; \n\
    \n\
    // interface library::IPropertiesContainer \n\
    STDMETHOD(GetValue)(_In_ UINT32 propertyId,foundation::IInspectable **ppValue) \n\
    { \n\
{2}\n\
        return _BaseType::GetValue(propertyId, ppValue); \n\
    } \n\
    \n\
    STDMETHOD(SetValue)(_In_ UINT32 propertyId, _In_ foundation::IInspectable *pValue) \n\
    { \n\
{3}\n\
        return _BaseType::SetValue(propertyId, pValue); \n\
    }\n\
    \n\
    // DO NOT MODIFY: Ancestor weak ref properties\n\
    private:\n\
{4}\n\
};\n\n\
";

// Temaplate for the OnSetValue ancestor case when the property is a raw container.
// {0} = Model type name camel case
// {1} = Property name camel case
// {2} = Ancestor property name
static const wchar_t* _fastModelAncestorTypeSetPropertyCaseStatement_Template =
L"\t\t\tcase {0}::Property_{1}:\n\
\t\t\t{\n\
\t\t\t\t{2} = pValue;\n\
\t\t\t\treturn S_OK; \n\
\t\t\t}";

// Temaplate for the OnGetValue ancestor case when the property is a raw container.
// {0} = Model type name camel case
// {1} = Property name camel case
// {2} = Ancestor property name
static const wchar_t* _fastModelAncestorTypeGetPropertyCaseStatement_Template =
L"\t\t\tcase {0}::Property_{1}:\n\
\t\t\t{\n\
\t\t\t\t{2}.CopyTo(ppValue);\n\
\t\t\t\treturn S_OK; \n\
\t\t\t}";

// Temaplate for the OnSetValue WeakRef case when the property is a raw container.
// {0} = Interface name
// {1} = Property name lower case
static const wchar_t* _fastModelWeakRefTypeSetPropertyCaseStatement_Template =
L"\
\t\t\t\tfoundation::ComPtr<{0}> spValue;\n\
\t\t\t\tif (pValue)\n\
\t\t\t\t{\n\
\t\t\t\t\tfoundation::IInspectable *pStrongRef = nullptr;\n\
\t\t\t\t\t// convert from Weak Reference storage value\n\
\t\t\t\t\tIFR_ASSERT(foundation::ResolveWeakRefWeak(foundation::AsWeakReference(pValue), foundation_IID_IInspectable, pStrongRef));\n\
\n\
\t\t\t\t\tIFR_ASSERT(foundation::QueryInterface(pStrongRef, spValue.GetAddressOf()));\n\
\t\t\t\t}\n\
\t\t\t\treturn this->GetOuter()->Set{1}Internal(spValue);\
";

// Temaplate for the OnGetValue WeakRef case when the property is a raw container.
// {0} = Interface name
// {1} = Property name lower case
static const wchar_t* _fastModelWeakRefTypeGetPropertyCaseStatement_Template =
L"\
\t\t\t\tfoundation::ComPtr<{0}> value;\n\
\t\t\t\tIFR_ASSERT(this->GetOuter()->Get{1}Internal(value.GetAddressOf()));\n\
\t\t\t\tif(value != nullptr)\n\
\t\t\t\t{\n\
\t\t\t\t\tIFR_ASSERT(AsWeakRef(\n\
\t\t\t\t\t\t*(reinterpret_cast<foundation::IWeakReference **>(ppValue)),\n\
\t\t\t\t\t\tvalue));\n\
\t\t\t\t}\n\
\t\t\t\treturn S_OK;\
";

// Template for the OnGetValue case when the property is a ptr.
// {0} = Model type name camel case
// {1} = Property name camel case
// {2} = Property name lower case
// {3} = Property type name
static const wchar_t* _fastModelPtrTypeGetPropertyCaseStatement_Template =
L"\t\t\tcase {0}::Property_{1}: \n\
\t\t\t{\n\
\t\t\t\treturn this->GetOuter()->Get{2}Internal(({3} **)ppValue);\n\
\t\t\t}";


// Template for the OnSetValue case when the property is a ptr.
// {0} = Model type name camel case
// {1} = Property name camel case
// {2} = Full property name
// {3} = Property name lower case
static const wchar_t* _fastModelPtrTypeSetPropertyCaseStatement_Template =
L"\
\t\t\t\tfoundation::ComPtr<{0}> spValue;\n\
\t\t\t\tif (pValue)\n\
\t\t\t\t{\n\
\t\t\t\t\tIFR_ASSERT(foundation::QueryInterface(pValue, spValue.GetAddressOf()));\n\
\t\t\t\t}\n\
\t\t\t\treturn this->GetOuter()->Set{1}Internal(spValue);\
";

// Template for the OnSetValue case when the property is a ptr.
// {0} = Model type name camel case
// {1} = Property name camel case
// {2} = Full property name
// {3} = Property name lower case
static const wchar_t* _fastModelUnkPtrTypeSetPropertyCaseStatement_Template =
L"\t\t\tcase {0}::Property_{1}:\n\
\t\t\t{\n\
\t\t\t\treturn this->GetOuter()->Set{2}Internal(pValue);\n\
\t\t\t}\n";

// Template to declare the private access interface to enable sets from consuming code.
// {0} = Model interface name.
// {1} = Gets/Sets definitions.
// {2} = Public interface for the model
static const wchar_t* _fastModelPrivateInterfaceDeclare_Template =
L"BEGIN_DECLARE_INTERNAL_INTERFACE({0},{2}) \n\
{1}\
END_DECLARE_INTERNAL_INTERFACE()\n\
\n\
 ";

// {0} = Private model interface name
// {1} = Public model interface
// {2} = Private definitions
static const wchar_t* _fastModelPrivateDerivedIntefaceDeclare_Template= 
L"BEGIN_DECLARE_IID({0},_VOID_MACRO) \n\
\n\
struct {0}:\n\
\tpublic {1},\n\
{\n\
\tpublic:\n\
\t\tstatic const IID& GetIID() { return IID_{0}; } \n\
\n\
{2}\n\
};\n\n";


// Template for the private get property access declaration interface
// {0} = Property name
// {1) = Property model type
// {2} = Get prefix for the method eg. Get ot get
static const wchar_t* _fastModelEmptyGetPropertyAccessInterfaceDeclare_Template =
L"\
\tvirtual HRESULT {2}{0}({1}* pValue) = 0;\n\
";

// Template for the private set property access declaration interface
// {0} = Property name
// {1) = Property model type
// {2} = Set prefix for the method eg. set ot set
static const wchar_t* _fastModelEmptySetPropertyAccessInterfaceDeclare_Template =
L"\
\tvirtual HRESULT{2}{0}({1} value) = 0; \n\
";

// Template for the private set property access declaration interface (Array)
// {0} = Property name
// {1) = Property model type
// {2} = Set prefix for the method eg. set ot set
static const wchar_t* _fastModelSetPropertyArrayAccessInterfaceDeclare_Template =
L"\
 \tvirtual HRESULT {2}{0}(UINT32 size,{1} value) = 0;\n\
 ";

// Template for the private get property access declaration interface (Array)
// {0} = Property name
// {1) = Property model type
// {2} = Get prefix for the method eg. Get ot get
static const wchar_t* _fastModelGetPropertyArrayAccessInterfaceDeclare_Template =
L"\
\tvirtual HRESULT{2}{0}(UINT32 *size, {1}*pValue) = 0; \n\
";

// Template to declare the base container friend relationship
// {0} = Base TypeInfo name
// {1} = TypeInfo name
static const wchar_t* _fastModelBaseContainerFriendDecl =
L"friend class _Fast{0}Container<fast_{1}<TBASE>>;";

static const wchar_t* _fastModelCustomBaseClass_Template =
L"_Fast{0} <T,TInterface,TBASE,_ModelContainerType>";

// {0} = Typeinfo to lower case convention
static const wchar_t* _fastModelBaseContainerFriend_Template =
L"friend class _Fast{0}Container<_This_Type>;";

// Template that contains the internal classes for the user models.
// {0} = Internal Model interface name.
// {1} = Model Base class
// {2} = Private model interface
// {3} = Initialize Model Implementation
// {4} = Command TypeDefs
// {5} = Default base class
// {6} = OnInvokeMethod override implementation
// {7} = Public property getters/setters and command implementations
// {8} = Private property getters/setters
// {9} = Internale property getter/setters methods
// {10} = Property containers definitions
// {11} = Base type QI
// {12} = Public interface
// {13} = Inneradapter container name
// {14} = Typeinfo to lowe case convention
// {15} = Container friends in the hieriechy
// {16} = OnGetProperty Internal if we need it
// {17} = Ensure property activations if we need it
// {18} = Custom public declaretion for the inheritance
// {29} = Initialize method name
// {20} = Base class definition
// {21} = Base class delegation for properties and methods
// {22} = Public Interface name
// {23} = Variadic base constructor
// {24} = NonVariadic base constructor
// {25} = Interface Template
// {26} = FinalRelease override implementation
// {27} = Typedef for base classes with empty brakets
static const wchar_t* _fastModelInternalCoreBaseClass_Template =
L"\
template <class TBASE{5}, class TModelPrivateInterface = {25}>\n\
class _Fast{0} : \n\
{20}{18}\n\
{ \n\
public: \n\
\t// Initialize Model \n\
\tHRESULT {19}()\n\
\t{\
\t\n\
\t\treturn TBASE::{19}(); \n\
\t}\n\n\
\t// Initialize Properies \n\
{3} \n\
protected: \n\
\ttemplate <typename... Arguments>\n\
\t_Fast{0}(_In_ Arguments&... params)\n\
\t{23}\
{\n\
\t}\n\
\n\
\ttypedef _Fast{0}<TBASE,TModelPrivateInterface> _This_Type; \n\
\t// Container friends for runtime support\n\
{15}\n\
\tfriend class _Fast{14}Container<_This_Type>; \n\
\n\
\tSTDMETHOD(OnCreatePropertiesContainer)(\n\
\t\t\t\t_In_ pmod::IObservableObjectInfo* pPropertyModelInfo,\n\
\t\t\t\t_In_ UINT32 size,\n\
\t\t\t\t_COM_Outptr_ foundation::library::IPropertiesContainer **ppValue) override\n\
\t{\n\
\t\tUNREFERENCED_PARAMETER(pPropertyModelInfo);\n\
\t\tUNREFERENCED_PARAMETER(size);\n\
\n\
\t\treturn pmod::library::_CreateFastPropertiesContainer<_Fast{14}Container<_This_Type>>(this, ppValue);\n\
\t}\n\
\n\
\n\
\t// overrides\n\
\n\
\t// commands typedefs \n\
{4} \n\
\n\
\tHRESULT QueryInterfaceImpl(REFIID iid, foundation::IUnknown **ppInterface) override \n\
\t{ \n\
\t\tif (iid == {2}::GetIID() || iid == {22}::GetIID())\n\
\t\t{\n\
\t\t\t*ppInterface = static_cast<{2} *>(this);\n\
\t\t}\n\
{11}\
\t\telse\n\
\t\t{\n\
\t\t\treturn TBASE::QueryInterfaceImpl(iid, ppInterface);\n\
\t\t}\n\
\t\treturn S_OK;\n\
\t} \n\
\n\
\t// Method Invoke overrides \n\
{6}\n\
\n\
{16}\n\
\n\
public:\n\
{7}\
\n\
public:\n\
    // Interface {2} \n\
{8}\
\n\
{21} \n\
\n\
protected:\n\
 \n\
    // internal get/set methods \n\
{9}\
\n\
{17}\n\
\n\
protected:\n\
\t// FinalRelease override\n\
\tvoid FinalRelease() override\n\
\t{{26}\n\
\t\tTBASE::FinalRelease();\n\
\t}\n\
\n\
//******************************************************************\n\
// WARNING: DIRECT USE OF THESE FIELDS OUTSIDE OF THE SDK OVERRIDES \n\
// REQUIRE MANUAL LOCKING MECHANISM TO ENSURE INTEGRITY\n\
//*******************************************************************/\n\
protected: \n\
    // Property containers \n\
{10}\
\n\
}; \n\
{27}\n\
";

//Template for the base QI if implementation
// {0} = Base type interface name
// {1} == IID Value
static const wchar_t* _fastModelBaseClassQI_Template =
L"\
\t\telse if (iid == {1})\n\
\t\t{\n\
\t\t\t*ppInterface = static_cast<{0} *>(this);\n\
\t\t}\n";

// Format template for Initialize Model
// {0} = Command creation and initialization
// {1} = properties initialization
// {1} = property runtime class initialization
static const wchar_t* _fastModelInitializeProperties_Template =
L" \
\tHRESULT _InitializeProperties() \n\
\t{ \n\
\t\t// property initialization\n\
{1}\n\
{0}\n\
{2}\n\
\t\treturn TBASE::_InitializeProperties(); \n\
\t} \n\
";

// Template to generate the inner adapter name
// {0} = Typeinfo name for the interface
static const wchar_t* _fastModelInnerAdpaterName_Template =
L"_p{0}AdapterInner";

// Template for final release override to clean up the inner adapter
// {0} = Inner private addapter container name.
static const wchar_t* _fastModelFinalReleaseImpl_Template =
L"\
\tvoid FinalRelease() override \n\
\t{\n\
\t\tReleaseInterface({0});\n\
\t\tTBASE::FinalRelease();\n\
\t}\n\
";

// Command model intializtion and creation
// {0} = Propery name
// {1} = Property name in lower case convention
// {2} = Private property container
static const wchar_t* _fastModelCommandCreateInstance_Template =
L"\t\t// property:{0} \n\
\t\tIFR_ASSERT({1}Command::CreateInstance(this, {2}.GetAddressOf()));\n\
\t\tthis->SetChildObject({2}->CastToUnknown());";

// Template to define the internal command models
// {0} = Model name in lower case convention
// {1} = Property name in lower case convention
static const wchar_t* _fastModelCommandModelTypeDefs_Template =
L"\
\tfriend class _Fast{0}{1}Command<_This_Type>;\n\
\ttypedef _Fast{0}{1}Command<_This_Type> {1}Command;";

// Command model container templates
// {0} = Command model type def name.
static const wchar_t* _fastModelCommandTypeDefName_Template =
L"{0}Command";

// Format template for Method Invoke Override
// {0} = Type Info Model
// {1} = method handler section
// {2} = foundation namespace
static const wchar_t* _fastModelMethodInvokeOverride_Template = 
L"\
\tSTDMETHOD(OnInvokeMethod)(_In_ {2}::IMethodInfo *pMethodInfo,_In_ UINT32 methodId,_In_ UINT32 size,_In_ foundation::IInspectable **parameters,foundation::IInspectable **ppResult ) override\n\
\t{\n\
\t\tUNREFERENCED_PARAMETER(ppResult); // in case no method impl has any return value\n\
\
\t\tHRESULT hr;\n\
\n\
\t\tswitch(methodId)\n\
\t\t{\n\
\t{1}\n\
\t\t\tdefault:\n\
\t\t\thr = TBASE::OnInvokeMethod(pMethodInfo,methodId,size,parameters,ppResult);\n\
\t\t}\n\
\t\treturn hr;\n\
\t}\n\
";

// {0} = OnProperty get internal case statements
static const wchar_t* _fastModelOnPropertyGetInternal_Template = L"\
\tSTDMETHOD(OnGetProperty)(UINT32 propertyId, _Inout_ foundation::IInspectable **ppValue) override\n\
\t{\n\
\t\tswitch (propertyId)\n\
\t\t{\n\
{0}\n\
\t\t\tdefault:\n\
\t\t\t\treturn TBASE::on_GetpropertyInternal(propertyId, ppValue);\n\
\t\t}\n\
\t\treturn S_OK;\n\
\t}\n\
";

// {0} = Extra indentation
// {1} = Lower case convention property name
static const wchar_t* _fastModelEnsureActivationCall_Template = L"\t\treturn this->ensure_{0}_activate(pValue);\n";

// {0} = Model namespace
// {1} = Model type info name
// {2} = Property name
// {3} = Runtime Class Options
static const wchar_t* _setPropertyRuntimeClassOptions_Template =
L"\t\tthis->SetPropertyRuntimeClassOptions({0}::{1}::Property_{2},{3});\n";

static const wchar_t* _propertyRuntimeClassOptions_Template =
L"{0}::library::PropertyRuntimeClassOptions::{1}";

// Template to call the ensure activation method for properties
// that implement dynamic loading.
// {0} = Model namespace
// {1} = Model type info name
// {2} = Property name
// {3} = Lower case convernation property name
// {4} = Property type Interface name
static const wchar_t* _fastModelOnPropertyGetInternalCase_Template = L"\
\t\t\tcase {0}::{1}::Property_{2}:\n\
\t\t\t\tif(*ppValue == nullptr)\n\
\t\t\t\t{\n\
\t\t\t\t\treturn ensure_{3}_activate(({0}::{4} **)ppValue);\n\
\t\t\t\t}\n\
\t\t\t\tbreak;\n\
";

// {0} = Lower case convention property name
// {1} = Property contianer name
// {2} = Model namespace
// {3} = Model type info name
// {4} = Property name
// {5} = Property type Interface name
static const wchar_t* _fastModelStrongRefEnsureActivation_Template = L"\
\tHRESULT ensure_{0}_activate({2}::{5}** pValue)\n\
\t{\n\
\t\t// dynamic loading for {4} \n\
\t\tIFR_ASSERT(Get{0}Internal(pValue));\n\
\t\tif (*pValue == nullptr)\n\
\t\t{\n\
\t\t\tIFR_ASSERT(foundation::library::CreateObjectFromFactory({2}::{3}::IIDType, foundation::ctl::inspectable::CastToInspectable(this), pValue));\n\
\t\t\tIFR_ASSERT(this->TrySetChildObject(*pValue));\n\
\t\t\treturn Set{0}Internal(*pValue);\n\
\t\t}\n\
\t\treturn S_OK;\n\
\t}\n\
";

// Private property model containers for raw type templates
// {0} = Property name in lower case convention.
static const wchar_t* _fastModelPropertyContainerName_Template =
L"_{0}Value";

// Private ancestor property model containers for raw type templates
// {0} = Property name in lower case convention.
static const wchar_t* _fastModelAncestorPropertyContainerName_Template =
L"_{0}Ancestor";

// {0} = Property type name
static const wchar_t* _fastModelWeakRefHolder_Template =
L"foundation::WeakReferenceHolder<{0}::{1}>";

// Private property model containers for ptr type templates
// {0} = Property type name
static const wchar_t* _fastModelComPtrWrapper_Template =
L"foundation::ComPtr<{0}>";

// {0} = Model namespace
// {1} = Model interface type name
// {2} = GUID
// {3} = GUID data string
// {4} = Interface name postfix
static const wchar_t* _fastModelPrivateInterfaceIId_Template =
L"// {{2}}\n\
const GUID {0}::IID_{1}{4} = \n\
    {3}\n";

static const wchar_t* _fastModelInterfaceExternDeclare_Template = L"BEGIN_DECLARE_IID({0}{1}, {2}) \n\n";

// Template to generate the  parent property get internal
// {0} = Type info name
// {1} = Property name
static const wchar_t* _fastModelParentPropertyGet_Template =
L"\
\t\tfoundation::InspectablePtr spVal;\n\
\t\tthis->GetInterface()->GetProperty({0}::Property_{1}, spVal.GetAddressOf());\n\
\t\treturn foundation::pv_util::GetValue(spVal, pValue);\n ";

// Template to generate the  ancestor property get internal
// {0} = Type info name
// {1} = Property name
static const wchar_t* _fastModelAncestorPropertyGet_Template =
L"\
 \t\tfoundation::InspectablePtr spVal;\n\
 \t\tthis->GetInterface()->GetProperty({0}::Property_{1}, spVal.GetAddressOf());\n\
 \t\treturn foundation::pv_util::GetValue(spVal, pValue);\n ";

static const wchar_t* _fastModelSetInternalArraySupport =
L"\
\t\tfoundation::InspectablePtr spPropertyValueArray;\n\
\t\tspPropertyValueArray = foundation::CreateValue(size, value);\n\
\t\t{0}.Clear();\n\
\t\treturn foundation::pv_util::GetValue(\n\
\t\t\tspPropertyValueArray,\n\
\t\t\t{0}.GetSizeAddressOf(),\n\
\t\t\t{0}.GetBufferAddressOf());";


//{0} = Raw type to return 
//{1} = Property name
//{2} = Intermediate container type
static const wchar_t* _fastModelGetAncestorTypeDirectly_Template =
L"\t{0} Get{1}()\n\
 \t{\n\
 \t\t{2}\n\
 \t\tTHROW_IFR(Get{1}(value.GetAddressOf()));\n\
 \t\treturn value;\n\
 \t}\n\
 ";

//{0} = Property or Array wrapper type.
//{1} = Property name 
//{2} = Array container name;
//{3} = const value
static const wchar_t* _fastModelGetArrayWrapperRef_Template =
L"\t{0} Get{1}() {3}\n\
\t{\n\
\t\treturn {2};\n\
\t}\n\
";

//{0} = Property type
//{1} = Property name 
//{2} = Proepty ptr type
//{3} = Property name lower case convention
static const wchar_t* _fastModelGetWeakPropertyRef_Template =
L"\t{0} Get{1}()\n\
\t{\n\
\t\t{2}\n\
\t\tTHROW_IFR(Get{3}Internal(value.GetAddressOf())); \n\
\t\treturn value; \n\
\t}\n\
";


// Format template for Invoke Sync
// {0} = Method Name
// {1} = lambda parameters
static const wchar_t* _methodInvokSyncFastModel_Template =
L"\
 \t{\n\
 \t\treturn this->RunWorkingDispatcherSync(\n\
 \t\t\t[=]() {\n\
 \t\t\t\treturn this->{0}Internal({1});\n\
 \t\t}); \n\
 \t}\n\
 ";

// Format template for Invoke Async
// {0} = Method Name
// {1} = local vars
// {2} = lambda parameters
// {3} = ptr -> interface conversion
// {4} = Method post fix
static const wchar_t* _methodInvokeAsyncFastModel_Template =
L"\
\t{\n\
{1}\n\
\t\treturn this->InvokeAsyncInternal(\n\
\t\t\t[=](const foundation::AsyncOperationClassPtr& async_operation_class) {\n\
\t\t\t\treturn this->{0}{4}({2}async_operation_class{3});\n\
\t\t}, pResult); \n\
\t}\n\
";

// Format template for Method Invoke 
// {0} = Type Model
static const wchar_t* _returFastnModelType_Template =
L"\
\t\t\tif(result != nullptr)\n\
\t\t\t{\n\
\t\t\t\thr = foundation::QueryInterface(result,pResult);\n\
\t\t\t}\n\
\t\t\telse\n\
\t\t\t{\n\
\t\t\t\t*pResult = nullptr;\n\
\t\t\t}\n\
";

const wchar_t *_AsyncPostFix = L"Async";
const wchar_t *_InternalPostFix = L"Internal";

//// {0} = Lower case type name
//static const wchar_t* _fastModelCreatePropertyValue_Template=
//L"foundation::pv_util::create_{0}_value";

void CGenerateFastCppTemplate::initialize(foundation::library::DictionaryClassPtr& parameters)
{
    CCodeGenToolBase::initialize(parameters);
    _useAsyncOperationClassPtr = getBoolParamater(parameters, L"useAsyncOperationClassPtr", false);
    _generateMethodInternal = getBoolParamater(parameters, L"generateMethodInternal", false);
}

void CGenerateFastCppTemplate::helpInternal(std::wostream& os)
{
    CCodeGenToolBase::helpInternal(os);
    os << "modelIncReferences: list of Type Info Ref header files" << std::endl;
    os << "modelAdapterInc: Adapter header file" << std::endl;
    os << "modelFastCppTemplateInc: CPP File for fast model adapters" << std::endl;
    os << "modelFastInterfaceHeaderInc: H File for fast model internal interfaces" << std::endl;
}

void CGenerateFastCppTemplate::codeGenerateEnd(foundation::library::DictionaryClassPtr& parameters) 
{
    std::wstring modelFastCppTemplateIncPath = getStringParameter(parameters, L"modelFastCppTemplateInc", nullptr);
    std::wstring modelFastInternalInterfaceHeaderIncPath = getStringParameter(parameters, L"modelFastInterfaceHeaderInc", nullptr);

    std::wostringstream osModelIncReferences;
    emitIncludeReferences(osModelIncReferences, parameters, L"modelIncReferences");

    std::wstring modelAdapterInc = getFilePath(getStringParameter(parameters, L"modelAdapterInc", nullptr));

    std::wstring cppCodeForInterfaces = modelFastCppTemplateIncPath.substr(0,modelFastCppTemplateIncPath.length()-2) + L".cpp";
    
    std::wstring cppCodeFileName = getFilePath(cppCodeForInterfaces);
    std::wstring fastModelInclude = getFilePath(modelFastCppTemplateIncPath);
    std::wstring modelFastInternalInterfaceHeaderInclude = getFilePath(modelFastInternalInterfaceHeaderIncPath);
    

    auto namespaceDeclare = toNativeNamespaceDeclare(this->getNativeNamespace());
    auto namespaceEnd = toNativeNamespaceEnd(this->getNativeNamespace());

    // generate H template Inc file
    std::wofstream fileFastModelHTemplateInc(ToUtf8String(modelFastCppTemplateIncPath.data()),std::ios_base::out);
    fileFastModelHTemplateInc << FormatW(_fastModelContainerHeader_Template,
        osModelIncReferences.str().data(),
        modelAdapterInc.data(),
        modelFastInternalInterfaceHeaderInclude.data(),
        namespaceDeclare.data(),
        _osFastModelContainersTemplates.str().data(),
        _osFastModelBaseClassTemplates.str().data(),
        namespaceEnd.data(),
        nullptr);
    
    // generate Cpp template Inc file
    std::wofstream fileFastModelCppTemplateInc(ToUtf8String(cppCodeForInterfaces.data()),std::ios_base::out);
    fileFastModelCppTemplateInc << FormatW(_fastModelPrivateInterfaceCpp_Template,
                                     fastModelInclude.data(),
                                     _osFastModelPrivateInterfaceIIDs.str().data(),
                                     nullptr);

    // generate internal interfaces Inc file
    std::wofstream fileFastModelInternaleInterfacesTemplateInc(ToUtf8String(modelFastInternalInterfaceHeaderIncPath.data()), std::ios_base::out);
    fileFastModelInternaleInterfacesTemplateInc << FormatW(_fastModelPrivateInterfaceHeader_Template,
        modelAdapterInc.data(),
        namespaceDeclare.data(),
        _osFastModelPrivateInterfaceDeclares.str().data(),
        namespaceEnd.data(),
        nullptr
        );

    fileFastModelHTemplateInc.close();
    fileFastModelCppTemplateInc.close();
    fileFastModelInternaleInterfacesTemplateInc.close();
}

void CGenerateFastCppTemplate::codeGenerate(const schema::CObservableObjectInfo *pPropertyModelInfo)
{	
    std::wstring typeInfoName = toTypeInfoName(pPropertyModelInfo->getName());

    std::wstring typeInfoNameCodeGen = this->toCodeGenTypeName(typeInfoName.c_str());

    // default base container class
    std::wstring typeInfoBaseNameCodeGen = L"pmod::library::_FastPropertiesContainer<T>";

    //  default base model class
    std::wstring modelClassBaseNameCodeGen = L"pmod::FastModelBase<T, TInterface, TBASE, _ModelContainerType>";
    std::wstring modelBaseDefinition = L"	pmod::library::_ObservableObjectAdapterBaseImpl\n\
    <\n\
    foundation::_ObjectAdapterBase\n\
    <\n\
    pmod::library::_FastBaseHelper<TBASE, TModelPrivateInterface>\n\
    >\n\
    >\n";

    // typedef for base classes that are not inheriting from any class.
    std::wstring typeDefBaseClass = FormatW(L"typedef _Fast{0}<> _Fast{0}Base;\n\n",typeInfoNameCodeGen.data(),nullptr);

    std::wstring baseAdapterType = L"pmod::library::_ObservableObjectAdapterBase<TInterface, piid>";

    std::wstring baseFriendAccess = L"";
    std::wstring custombaseTypeQI = L"";
    std::wstring initializeMethodName = L"_InitializeModel";
    
    std::wostringstream baseMemberDelegates;
    std::wostringstream baseMemberQualifications;
    // check for base type
    if (pPropertyModelInfo->getBaseType())
    {        
        std::wstring typeInfoBaseName = toTypeInfoName(pPropertyModelInfo->getBaseType()->getName());
        baseAdapterType = L"T"+ typeInfoBaseName + L"FastModelAdapter<TInterface, piid>";
        //Attach template params
        typeInfoBaseNameCodeGen = L"_Fast" + this->toCodeGenTypeName(typeInfoBaseName) + L"Container<T>";

        baseFriendAccess = FormatW(_fastModelBaseContainerFriendDecl, this->toCodeGenTypeName(typeInfoBaseName).data(), typeInfoNameCodeGen.data(), nullptr);

        modelClassBaseNameCodeGen = FormatW(_fastModelCustomBaseClass_Template, this->toCodeGenTypeName(typeInfoBaseName).data(), pPropertyModelInfo->getBaseType()->getName().data(), nullptr);        

        // Write Properties and methods for base class delegation
        schema::CObservableObjectInfo* baseType = (schema::CObservableObjectInfo *)(pPropertyModelInfo->getBaseType());

        if(!baseType->getBaseType())
        {
            modelBaseDefinition = L"pmod::library::_DelegateFastModelBase<TBASE, TModelPrivateInterface>";
        }
        else
        {
            std::wstring baseName = this->toCodeGenTypeName(toTypeInfoName(baseType->getName()).c_str());
            modelBaseDefinition = FormatW(L"_Fast{0}<TBASE, TModelPrivateInterface>",baseName.data(),nullptr);
        }

        baseMemberDelegates << "// " <<pPropertyModelInfo->getBaseType()->getName() << "Interface" << std::endl;
        
        // emit base properties for delegating.
        for (schema::_PropertyIteratorType::const_iterator iter = baseType->getProperties().begin();
        iter != baseType->getProperties().end();
        ++iter)
        {
            emitPropertyBaseTypeDelegate(baseMemberDelegates, baseMemberQualifications,(*iter));
        }

        // Iterate Methods for the base class to generate the delegated
        for (schema::_MethodIteratorType::const_iterator iter = baseType->getMethods().begin();
            iter != baseType->getMethods().end();
            ++iter)
        {
            // emit method handler for class template
            emitMethodBaseTypeDelegate(baseMemberDelegates, baseMemberQualifications, *iter);
        }
    }

    // Emit get/set value cases
    std::wostringstream getValueCases;
    std::wostringstream setValueCases;
    std::wostringstream commandInitializations;
    std::wostringstream commandTypedefs;
    std::wostringstream commandVirtualMethods;
    std::wostringstream propertyContainers;
    std::wostringstream ancestorPropertyContainers;
    std::wostringstream osPropertyContainersInitializers;
    std::wostringstream osPublicAccess;
    std::wostringstream osInternalAccess;
    std::wostringstream osPrivateAccess;
    std::wostringstream osPrivateAccessDeclare;
    std::wostringstream osAncestorFriendContainerDeclare;
    std::wostringstream osOngetPropertyInternalCases;
    std::wostringstream osEnsurePropertyActivation;
    std::wostringstream osPropertiesRuntimeClassOptionsInitializers;
    std::wostringstream osContainerReleaseStatements;

    // Iterate Properties
    for (schema::_PropertyIteratorType::const_iterator iter = pPropertyModelInfo->getProperties().begin();
        iter != pPropertyModelInfo->getProperties().end();
        ++iter)
    {
        emitGetSetValuePropertyCases(getValueCases, setValueCases, (*iter));
        bool isAncestor = ((*iter)->getFlags() & PropertyFlagType_IsAncestor) != 0;

        // generate Command Internal support
        if ((*iter)->getModelType() != nullptr &&
            (*iter)->getModelType()->getModelType() == schema::ModelTypeInfoType_Command)
        {
            if ((*iter)->isAutoGenerate())
            {

                CGenerateCppLibrary::emitPropertyCommandHandler(
                    _osFastModelBaseClassTemplates,
                    (*iter),
                    FormatW(L"_WeakRefCommandClass<T,{0}>", pPropertyModelInfo->getName().data(),nullptr).c_str(),
                    L"_Fast");
            }
        }

        // Generation activation for dynamic properties
        emitActivationSupport(osOngetPropertyInternalCases,osEnsurePropertyActivation,(*iter));
        
        // validate if we need to generate the container
        // it will not be generated for parent property or custom container
        if (!(*iter)->isParent() && !(*iter)->isCustomContainer())
        {
            emitPropertyInitializer(osPropertyContainersInitializers, (*iter));
        }
        emitPropertyAccessMethods(osPublicAccess, osInternalAccess, osPrivateAccess, osPrivateAccessDeclare, (*iter));
    
        // we dont not need contaiers for parent properties
        if (!(*iter)->isParent() && !(*iter)->isCustomContainer() && !isAncestor )
        {
            emitPropertyContainer(propertyContainers, (*iter));
            emitContainerReleaseStatement(osContainerReleaseStatements, (*iter));
        }
        
        if (isAncestor)
        {
            ancestorPropertyContainers << "\tfoundation::InspectablePtr " << toAncestorContainerName((*iter)->getName().c_str()) << ";" << std::endl;
        }

        // only generate commands if they are not marked as auto generate
        if ((*iter)->isAutoGenerate())
        {
            if ((*iter)->getModelType() && (*iter)->getModelType()->getModelType() == schema::ModelTypeInfoType_Command)
            {
                emitCommandInitializer(commandInitializations, commandTypedefs, (*iter));
                emitPropertyCommandHandler(commandVirtualMethods, (*iter));
            }
        }
        if ((*iter)->getRuntimeClassOptions() != 0)
        {
            UINT32 runtimeClassOptions = (*iter)->getRuntimeClassOptions();
            std::wstring libraryRuntimeClassOptions;
            if ((runtimeClassOptions & 1) != 0)
            {
                libraryRuntimeClassOptions += FormatW(_propertyRuntimeClassOptions_Template, getCoreNamespace(), L"UseWorkingDispatcherOnGetProperty", nullptr);
            }
            // note: put extra  code here to continue constructing the options 
            if ((runtimeClassOptions & 2) != 0)
            {
                if (libraryRuntimeClassOptions.size())
                {
                    libraryRuntimeClassOptions += L" | ";
                }
                libraryRuntimeClassOptions += FormatW(_propertyRuntimeClassOptions_Template, getCoreNamespace(), L"UseWorkingDispatcherOnSetProperty", nullptr);
            }

            osPropertiesRuntimeClassOptionsInitializers <<
                FormatW(_setPropertyRuntimeClassOptions_Template,
                getNamespace().c_str(),
                typeInfoName.c_str(),
                (*iter)->getName().c_str(),
                FormatW(L"({0}::library::PropertyRuntimeClassOptions)({1})", getCoreNamespace(),libraryRuntimeClassOptions.c_str(),nullptr).c_str(),
                nullptr);
        }
    }

    // Generate Source Property if this is a viewmodel
    if (pPropertyModelInfo->getModelType() == schema::ModelTypeInfoType_ViewModel)
    {
        initializeMethodName = L"_Initialize_viewmodel";
        const schema::CObservableObjectInfo *pSourceType = ((const schema::CPropertyViewModelInfo *)pPropertyModelInfo)->getSourceType();
        // Emit Header
        osPrivateAccessDeclare << "\tvirtual HRESULT GetSource(";
        this->emitModelTypeInfo(osPrivateAccessDeclare, pSourceType);
        osPrivateAccessDeclare << "** ppValue) = 0;" << std::endl;
       
        // Emit Source
        osPublicAccess << "\tHRESULT GetSource(";
        this->emitModelTypeInfo(osPublicAccess, pSourceType);
        osPublicAccess << "** ppValue)" << std::endl;
        osPublicAccess << "\t{" << std::endl;
        osPublicAccess << "\t\treturn this->GetModelProperty(" << getCoreNamespace() << "::Property_Source,ppValue);" << std::endl;
        osPublicAccess << "\t}" << std::endl;        

    }

    // emit property containers
    _osFastModelContainersTemplates << FormatW(_fastModelContainerClass_Template,
        typeInfoNameCodeGen.data(),
        typeInfoBaseNameCodeGen.data(),
        getValueCases.str().length() != 0 ? FormatW(_fastModelGetSetValueSwitchTemplate, getValueCases.str().data(), nullptr).data() : L"",
        setValueCases.str().length() != 0 ? FormatW(_fastModelGetSetValueSwitchTemplate, setValueCases.str().data(), nullptr).data() : L"",
        ancestorPropertyContainers.str().data(),// Ancestor Containers
        nullptr
        );

    //generate initialize method for base class
    std::wstring fastModelInitialization = FormatW(_fastModelInitializeProperties_Template,
                                                    commandInitializations.str().data(),
                                                    osPropertyContainersInitializers.str().c_str(),
                                                    osPropertiesRuntimeClassOptionsInitializers.str().c_str(),
                                                    nullptr);

    std::wostringstream osMethodHandler;
    std::wostringstream osAbstractMethods;

    // Iterate Methods
    for (schema::_MethodIteratorType::const_iterator iter = pPropertyModelInfo->getMethods().begin();
        iter != pPropertyModelInfo->getMethods().end();
        ++iter)
    {
        if ((*iter)->getIsAsync() || _generateMethodInternal)
        {
            emitWrapperMethod(osAbstractMethods, (*iter));
        }
        // emit method handler for class template
        emitMethodHandler(osMethodHandler, osAbstractMethods, *iter, false);
    }

    std::wstring methodInvokeOverride;
    if (pPropertyModelInfo->getMethods().size())
    {
        methodInvokeOverride = FormatW(
            _fastModelMethodInvokeOverride_Template,
            typeInfoName.data(),
            osMethodHandler.str().data(),
            this->getFoundationNamespace(),
            nullptr);
    }
    
    std::wstring strPrivateAccessDeclare = osPrivateAccessDeclare.str();
    std::wstring strCustomInterfaceName = pPropertyModelInfo->getCustomInterfaceName();

    
    _osFastModelPrivateInterfaceDeclares << FormatW(_fastModelPrivateInterfaceDeclare_Template,
        (pPropertyModelInfo->getName() + L"Private").data(),
        strPrivateAccessDeclare.data(),
        pPropertyModelInfo->getName().data(),
        nullptr);		
    
    if (strCustomInterfaceName.size() != 0)
    {
        _osFastModelPrivateInterfaceDeclares << FormatW(_fastModelInterfaceExternDeclare_Template,
            strCustomInterfaceName.data(),
            L"", // Postfix not used
            L"_VOID_MACRO", // No need for exporting this ID
            nullptr);

        std::wstring customIdValue = L"IID_" + strCustomInterfaceName;

        custombaseTypeQI = FormatW(_fastModelBaseClassQI_Template, strCustomInterfaceName.data()
                        ,customIdValue.data(), nullptr);
    }

    // generate the unique iid for the private access interface
    IID iidPrivateModeTypeAccess = createUniqueIId(pPropertyModelInfo);

    std::wostringstream osIIDGuidData;
    formatIIDType(osIIDGuidData, iidPrivateModeTypeAccess);

    _osFastModelPrivateInterfaceIIDs << FormatW(_fastModelPrivateInterfaceIId_Template,
        getNativeNamespace().data(),
        pPropertyModelInfo->getName().data(),
        toIdlIIDType(iidPrivateModeTypeAccess).data(),
        osIIDGuidData.str().data(),
        L"Private",
        nullptr);
    
    bool hasCustomInterfaceName = false;
    bool isCustomPrivateInterface = true;
    if (strCustomInterfaceName.size() != 0)
    {
        hasCustomInterfaceName = true;
        isCustomPrivateInterface = pPropertyModelInfo->isCustomPrivateInterface();

        // generate the unique iid for the custom access interface
        IID iidCustomModeTypeAccess = createUniqueIId(pPropertyModelInfo, L"Custom");
        std::wostringstream osCustomIIDGuidData;
        formatIIDType(osCustomIIDGuidData, iidCustomModeTypeAccess);

        _osFastModelPrivateInterfaceIIDs << FormatW(_fastModelPrivateInterfaceIId_Template,
            getNativeNamespace().data(),
            strCustomInterfaceName.data(),
            toIdlIIDType(iidCustomModeTypeAccess).data(),
            osCustomIIDGuidData.str().data(),
            L"", // Postfix not used
            nullptr);
    }
    emitAncestorContainerFriendDecl(osAncestorFriendContainerDeclare, pPropertyModelInfo);

    std::wstring ensureActivation = L"";
    std::wstring onGetPropetyInternal = L"";
    
    if (osEnsurePropertyActivation.tellp())
    {
        ensureActivation = osEnsurePropertyActivation.str();
        onGetPropetyInternal = FormatW(_fastModelOnPropertyGetInternal_Template, osOngetPropertyInternalCases.str().data(), nullptr);;
    }

    std::wstring privateInterfaceName = pPropertyModelInfo->getName() + L"Private";

    // emit base internal templates
    _osFastModelBaseClassTemplates << FormatW(_fastModelInternalCoreBaseClass_Template,
        typeInfoNameCodeGen.data(),
        modelClassBaseNameCodeGen.data(),
        privateInterfaceName.data(),
        fastModelInitialization.data(),
        commandTypedefs.str().data(),
        pPropertyModelInfo->getBaseType() == nullptr ? 
            FormatW(L" = {0}::library::_FastModelBase<>", getCoreNamespace(), nullptr).c_str():
            L"",
        methodInvokeOverride.data(),
        FormatW(L"{0}\n{1}\nprotected:\n{2}\n",osPublicAccess.str().data(),
                osAbstractMethods.str().data(),
                commandVirtualMethods.str().data(),
                nullptr).data(),
        osPrivateAccess.str().data(),
        osInternalAccess.str().data(),
        propertyContainers.str().data(),
        custombaseTypeQI.data(),
        pPropertyModelInfo->getName().data(),
        FormatW(_fastModelInnerAdpaterName_Template, typeInfoName.data(), nullptr).data(),
        typeInfoNameCodeGen.data(),
        osAncestorFriendContainerDeclare.str().data(),
        onGetPropetyInternal.data(),
        ensureActivation.data(),
        hasCustomInterfaceName && !isCustomPrivateInterface ? (L",\n\tpublic " + strCustomInterfaceName).data() : L"",
        initializeMethodName.data(),
        (L"public " + modelBaseDefinition).data(),
        baseMemberDelegates.tellp() ? baseMemberDelegates.str().data() : L"",
        pPropertyModelInfo->getName().data(),
        pPropertyModelInfo->getBaseType() == nullptr ? L"" : (L":" + modelBaseDefinition + L"(params...)\n").data(),
        pPropertyModelInfo->getBaseType() == nullptr ? L"" : (L":" + modelBaseDefinition + L"(parameter)\n").data(),
        hasCustomInterfaceName && isCustomPrivateInterface ? strCustomInterfaceName.data() : privateInterfaceName.data(),
        osContainerReleaseStatements.str().data(),
        pPropertyModelInfo->getBaseType() == nullptr ? typeDefBaseClass.data() : L"",
        nullptr
        );
}

 void CGenerateFastCppTemplate::emitPropertyBaseTypeDelegate(
        std::wostream& os,
        std::wostream& osQualifications,
        const schema::CPropertyInfo* pPropertyInfo)
 {
    std::wstring typeInfoName = toTypeInfoName(pPropertyInfo->getParent().getName());

    std::wstring typeInfoNameCodeGen = this->toCodeGenTypeName(typeInfoName);

    std::wstring propertyNameCodeGen = this->toCodeGenTypeName(pPropertyInfo->getName());

    bool isPropertyArray = (pPropertyInfo->getPropertyType() & 0x400) != 0;
    bool isAncestor = (pPropertyInfo->getFlags() & PropertyFlagType_IsAncestor) != 0;
  
    os << "\t// Property:" << pPropertyInfo->getName() << std::endl;

    // Emit public Get method
    os << "\tHRESULT " << "Get" << pPropertyInfo->getName() << "(";
    emitDeclarePropertyTypeInfo(os, pPropertyInfo, true);
    os << " pValue) override" << std::endl;
    os << "\t{" << std::endl;   
    os << "\t\treturn TBASE::Get" << pPropertyInfo->getName() << "("<<(isPropertyArray ? "size ," : "") << "pValue);" << std::endl;  
    os << "\t}" << std::endl;

    
    if(!pPropertyInfo->isCustomContainer())
    {
        std::wostringstream returnTypeDeclare;
        if (isPropertyArray)
        {            			
            returnTypeDeclare << "const ";
            emitArrayWrapperType(returnTypeDeclare, pPropertyInfo, L"", true);
        }
        else
        {
            emitWrapperPropertyTypeInfo(returnTypeDeclare, pPropertyInfo);
        }

        // make simple types getter methods be const.
        std::wstring methodConst;
        if (!pPropertyInfo->getModelType() || pPropertyInfo->getModelType()->getModelType() == schema::ModelTypeInfoType_Enum)
        {
            methodConst = L"const";
        }

        os << "\t"<< returnTypeDeclare.str() << " Get" << pPropertyInfo->getName() << "() " << methodConst << std::endl;
        os << "\t{" << std::endl;   
        os << "\t\treturn TBASE::Get" << pPropertyInfo->getName() << "();" << std::endl;  
        os << "\t}" << std::endl;
    }

    // Emit public Get method qualification
    osQualifications << "\tusing "<<pPropertyInfo->getParent().getName()<< "Private::" << "Get" << pPropertyInfo->getName() << ";" <<std::endl;
    
    if(!pPropertyInfo->isParent() && !isAncestor)
    {
        // Emit public set method
        os << "\tHRESULT " << "Set" << pPropertyInfo->getName() << "(";
        emitDeclarePropertyTypeInfo(os, pPropertyInfo, false);
        os << " value) override" << std::endl;
        os << "\t{" << std::endl;
        os << "\t\treturn TBASE::Set" << pPropertyInfo->getName() << "("<<(isPropertyArray ? "size ," : "") << "value);" << std::endl;  
        os << "\t}" << std::endl;

        // Emit public set method qualification
        osQualifications << "\tusing "<<pPropertyInfo->getParent().getName()<< "Private::" << "Set" << pPropertyInfo->getName() << ";" <<std::endl;
    }
 }

void CGenerateFastCppTemplate::emitMethodBaseTypeDelegate(
    std::wostream& osPrivateAdapterImpl,
    std::wostream& osQualifications,
    const schema::CMethodInfo*pMethodInfo)
{
    std::wostringstream adapterCall;
    adapterCall << "\t\treturn TBASE::";
    
    bool hasResult = pMethodInfo->getResultType() && pMethodInfo->getResultType()->getPropertyType() != foundation::PropertyType_Empty;

    std::wstring methodNameCallback = pMethodInfo->getName();

    osPrivateAdapterImpl << "\tHRESULT " << pMethodInfo->getName() << "(";
    adapterCall << pMethodInfo->getName() << "(";

    // Emit public method qualification
    osQualifications << "\tusing "<<pMethodInfo->getParent().getName()<< "Private::" << pMethodInfo->getName() << ";" <<std::endl;
   
    int parameterIndex = 1;
    for (schema::_MethodParamIteratorType::const_iterator iterParam = pMethodInfo->getParameters().begin();
        iterParam != pMethodInfo->getParameters().end();
        ++iterParam)
    {
        // Emit Virtual abstract params
        if (iterParam != pMethodInfo->getParameters().begin())
        {
            osPrivateAdapterImpl << ",";
            adapterCall << ",";
        }
        
        emitModelPropertyTypeInfo(osPrivateAdapterImpl, (*iterParam), false, parameterIndex);
        
        osPrivateAdapterImpl << " " << (*iterParam)->getParameterName();

        if ((*iterParam)->getPropertyType() & 0x400)
        {           
            adapterCall << "size";
            if (parameterIndex)
            {
                adapterCall << "_" << parameterIndex;
            }
            adapterCall << ",";
        }

        adapterCall << (*iterParam)->getParameterName();

        ++parameterIndex;
    }

    if ((hasResult || pMethodInfo->getIsAsync()) && pMethodInfo->getParameters().size())
    {	
        osPrivateAdapterImpl << ",";
        adapterCall << ",";
    }

    if (pMethodInfo->getIsAsync())
    {
        if (hasResult)
        {          
            osPrivateAdapterImpl << toPropertyTypeInfoAsync(pMethodInfo->getResultType(), true) << " **pAsyncOperation";          
        }
        
        if (hasResult)
        {
            adapterCall << "pAsyncOperation";
        }
    }
    else if (hasResult)
    {
        emitModelPropertyTypeInfo(osPrivateAdapterImpl, pMethodInfo->getResultType(), true);

        osPrivateAdapterImpl << " pResult";
        
        if (pMethodInfo->getResultType()->getPropertyType() & 0x400)
        {
            adapterCall << "size";           
            adapterCall << ",";
        }
        adapterCall << "pResult";
    }

    adapterCall << ");\n";

    osPrivateAdapterImpl << ")\n"
        << "\t{\n"
        << adapterCall.str()
        << "\t}\n" << std::endl;
}

void CGenerateFastCppTemplate::emitActivationSupport(
    std::wostream& osOngetPropertyCases,
    std::wostream& osEnsureActivation,
    const schema::CPropertyInfo*pPropertyInfo)
{
    const schema::CTypeInfo *pModelTypeInfo = pPropertyInfo->getModelType();

    schema::ModelTypeInfoType modelType = pModelTypeInfo ?
        pModelTypeInfo->getModelType() : schema::ModelTypeInfoType_None;

    if (!pPropertyInfo->isRuntimeActivated() || modelType == schema::ModelTypeInfoType_Enum || modelType == schema::ModelTypeInfoType_None)
    {
        return;
    }

    osOngetPropertyCases << FormatW(_fastModelOnPropertyGetInternalCase_Template,
        getNativeNamespace().data(),
        toTypeInfoName(pPropertyInfo->getParent().getName().c_str()).data(),
        pPropertyInfo->getName().data(),
        this->toCodeGenTypeName(pPropertyInfo->getName()).data(),
        pModelTypeInfo->getName().data(),
        nullptr);
    
    // Generate ensure activation
    osEnsureActivation << FormatW(_fastModelStrongRefEnsureActivation_Template,
        this->toCodeGenTypeName(pPropertyInfo->getName()).data(),
        toContainerPropertyName(pPropertyInfo->getName().c_str()).data(),
        getNativeNamespace().data(),
        toTypeInfoName(pModelTypeInfo->getName().c_str()).data(),
        pPropertyInfo->getName().data(),
        pModelTypeInfo->getName().data(),
        nullptr);
   
}

void CGenerateFastCppTemplate::emitCommandInitializer(
    std::wostream& createinstance,
    std::wostream& typedefs,
    const schema::CPropertyInfo*pPropertyInfo)
{	
    createinstance << FormatW(_fastModelCommandCreateInstance_Template,
        pPropertyInfo->getName().data(),
        this->toCodeGenTypeName(pPropertyInfo->getName()).data(),
        (L"_" + this->toCodeGenVarName(pPropertyInfo->getName()) + L"Value").data(),
        nullptr) << std::endl;

    std::wstring commandParentName = toTypeInfoName(pPropertyInfo->getParent().getName().c_str());
    typedefs << FormatW(_fastModelCommandModelTypeDefs_Template,
        this->toCodeGenTypeName(commandParentName).data(),
        this->toCodeGenTypeName(pPropertyInfo->getName()).data(),
        nullptr) << std::endl;
}

std::wstring CGenerateFastCppTemplate::getPropertyCaseInvoke(const schema::CPropertyInfo*pPropertyInfo, bool isGet)
{
    std::wstring propertyInfoNameCodeGen = this->toCodeGenTypeName(pPropertyInfo->getName());

    return FormatW(
        isGet ? L"Get{0}Internal" : L"Set{0}Internal",
        propertyInfoNameCodeGen.data(),
        nullptr);
}

void CGenerateFastCppTemplate::emitGetSetValuePropertyCases(
    std::wostream& getValueCases,
    std::wostream& setValueCases,
    const schema::CPropertyInfo*pPropertyInfo)
{
    bool isAncestor = (pPropertyInfo->getFlags() & PropertyFlagType_IsAncestor) != 0;
    std::wstring parentInfoName = toTypeInfoName(pPropertyInfo->getParent().getName());
    std::wstring propertyInfoName = pPropertyInfo->getName();

    if (isAncestor)
    {
        getValueCases << FormatW(_fastModelAncestorTypeGetPropertyCaseStatement_Template,
            parentInfoName.data(),
            propertyInfoName.data(),
            toAncestorContainerName(pPropertyInfo->getName().c_str()).data(),
            nullptr) << std::endl;


        setValueCases << FormatW(_fastModelAncestorTypeSetPropertyCaseStatement_Template,
            parentInfoName.data(),
            propertyInfoName.data(),
            toAncestorContainerName(pPropertyInfo->getName().c_str()).data(),
            nullptr) << std::endl;

    }
    else
        CGenerateCppLibrary::emitGetSetValuePropertyCases(&getValueCases, &setValueCases, pPropertyInfo);
}

std::wstring CGenerateFastCppTemplate::getPropertyCaseObjectInvokeImpl(
	const schema::CPropertyInfo*pPropertyInfo,
	const std::wstring& propertyModelTypeName,
	bool isGet)
{
    //std::wstring parentInfoName = toTypeInfoName(pPropertyInfo->getParent().getName());
    std::wstring propertyInfoNameCodeGen = this->toCodeGenTypeName(pPropertyInfo->getName());

    //std::wstring propertyModelTypeName = toNativePropertyType(pPropertyInfo);
    //std::wstring propertyInfoName = pPropertyInfo->getName();

    //// check if there is a PropertyModel type to generate the cast
    //bool isUnknownType = true;
    //if (pPropertyInfo->getModelType())
    //{
    //    propertyModelTypeName = toPropertyTypeName(pPropertyInfo);
    //    isUnknownType = false;
    //}
        
    if (isGet && pPropertyInfo->getFlags() & PropertyFlagType_IsWeakReference)
    {
        return FormatW(_fastModelWeakRefTypeGetPropertyCaseStatement_Template,
            propertyModelTypeName.data(),
            propertyInfoNameCodeGen.data(),
            nullptr);
    }
    //else
    //{
    //    *pGetValueCases << FormatW(_fastModelPtrTypeGetPropertyCaseStatement_Template,
    //        parentInfoName.data(),
    //        propertyInfoName.data(),
    //        propertyInfoNameCodeGen.data(),
    //        propertyModelTypeName.data(),
    //        nullptr) << std::endl;
    //}
        
    if (!isGet && !pPropertyInfo->isParent())
    {
        if (pPropertyInfo->getFlags() & PropertyFlagType_IsWeakReference)
        {
            return FormatW(_fastModelWeakRefTypeSetPropertyCaseStatement_Template,
                propertyModelTypeName.data(),
                propertyInfoNameCodeGen.data(),
                nullptr);
        }
 /*       else if (!pPropertyInfo->getModelType())
        {                
            return FormatW(_fastModelUnkPtrTypeSetPropertyCaseStatement_Template,
            parentInfoName.data(),
            propertyInfoName.data(),                
            propertyInfoNameCodeGen.data(),
            nullptr) << std::endl;
        }
        else
        {
            *pSetValueCases << FormatW(_fastModelPtrTypeSetPropertyCaseStatement_Template,
                parentInfoName.data(),
                propertyInfoName.data(),
                propertyModelTypeName.data(),
                propertyInfoNameCodeGen.data(),
                nullptr) << std::endl;
        }*/
    }
	return CGenerateCppLibrary::getPropertyCaseObjectInvokeImpl(pPropertyInfo, propertyModelTypeName, isGet);
}


void CGenerateFastCppTemplate::emitPropertyTypeInitializer(
    std::wostream& os,
    foundation::PropertyType propertyType)
{
    // skip arrays
    if (propertyType & 0x400)
    {
        return;
    }

    switch (propertyType & 0xff)
    {
    case foundation::PropertyType::PropertyType_UInt8:
    case foundation::PropertyType::PropertyType_Int16:
    case foundation::PropertyType::PropertyType_UInt16:
    case foundation::PropertyType::PropertyType_Int32:
    case foundation::PropertyType::PropertyType_UInt32:
    case foundation::PropertyType::PropertyType_Int64:
    case foundation::PropertyType::PropertyType_UInt64:
    case foundation::PropertyType::PropertyType_Single:
    case foundation::PropertyType::PropertyType_Double:
        os << L"0";
        break;
    case foundation::PropertyType::PropertyType_Char16:
        os << L"''";
        break;
    case foundation::PropertyType::PropertyType_Boolean:
        os << "false";
        break;
    case foundation::PropertyType::PropertyType_String:
    case foundation::PropertyType::PropertyType_Inspectable:
        break;
    case foundation::PropertyType::PropertyType_DateTime:
        // TODO:
        break;
    case foundation::PropertyType::PropertyType_TimeSpan:
        // TODO:
        break;
    case foundation::PropertyType::PropertyType_Guid:
        os << "foundation_GUID_NULL;";
        break;
    case foundation::PropertyType::PropertyType_Point:
    case foundation::PropertyType::PropertyType_Size:
    case foundation::PropertyType::PropertyType_Rect:
    default:
        assert(false);
    }
}

void CGenerateFastCppTemplate::emitPropertyContainer(
    std::wostream& os,
    const schema::CPropertyInfo*pPropertyInfo)
{
    foundation::PropertyType propType = pPropertyInfo->getPropertyType();

    std::wstring propertyModelTypeName = toNativePropertyType(propType);
    std::wstring propertyInfoName = pPropertyInfo->getName();
    
    //// generate the get value cases
    if (pPropertyInfo->getModelType())
    {	
        if (pPropertyInfo->getFlags() & PropertyFlagType_IsWeakReference)
        {
            propertyModelTypeName = FormatW(_fastModelWeakRefHolder_Template, getNativeNamespace().data(),pPropertyInfo->getModelType()->getName().data(), nullptr);
        }
        // command special case to generate the pointer using the command_model object
        else if (pPropertyInfo->getModelType()->getModelType() == schema::ModelTypeInfoType_Command)
        {
            std::wstringstream commandInterface;
            commandInterface << toPropertyTypeName(pPropertyInfo);

            propertyModelTypeName = FormatW(_fastModelComPtrWrapper_Template,
                (pPropertyInfo->isAutoGenerate()) ?
                    FormatW(
                        _fastModelCommandTypeDefName_Template,
                        this->toCodeGenTypeName(pPropertyInfo->getName()).data(),
                        nullptr).data() :
                    commandInterface.str().data(),
                nullptr);
        }
        else
        {
            os << "\t";
            emitModelTypeVarDeclare(os, pPropertyInfo, toContainerPropertyName(pPropertyInfo->getName().c_str()).c_str());
            return;
        }
    }
    else 
    {
        if (pPropertyInfo->getFlags() & PropertyFlagType_IsWeakReference && pPropertyInfo->getPropertyType() == foundation::PropertyType_Inspectable)
        {            
            propertyModelTypeName = L"foundation::WeakReferenceHolder<foundation::IInspectable>";
        }
        else
        {
            os << "\t";
            emitModelTypeVarDeclare(os, pPropertyInfo, toContainerPropertyName(pPropertyInfo->getName().c_str()).c_str());
            return;
        }
    }

    os << "\t" << propertyModelTypeName + L" " + toContainerPropertyName(pPropertyInfo->getName().c_str()) << L";" << std::endl;
}

void CGenerateFastCppTemplate::emitPropertyInitializer(
    std::wostream& os,
    const schema::CPropertyInfo*pPropertyInfo)
{
    std::wostringstream osInitializer;

    if (isPropertyTypeInfoEnum(pPropertyInfo) && !isPropertyTypeInfoArray(pPropertyInfo))
    {
        // Enum Type Info generation
        osInitializer << "(";
        this->emitFullName(osInitializer, pPropertyInfo->getModelType());
        osInitializer << ")0;";
    }
    else
    {
        emitPropertyTypeInitializer(osInitializer, pPropertyInfo->getPropertyType());
    }

    if (osInitializer.tellp())
    {
        os << L"\t\t" << toContainerPropertyName(pPropertyInfo->getName().c_str()) << " = " << osInitializer.str() << L";" << std::endl;
    }
}

std::wstring CGenerateFastCppTemplate::toContainerPropertyName(const wchar_t *pString)
{
    return FormatW(
        _fastModelPropertyContainerName_Template,
        this->toCodeGenVarName(pString).data(),
        nullptr);
}

std::wstring CGenerateFastCppTemplate::toAncestorContainerName(const wchar_t *pString)
{
    return FormatW(
        _fastModelAncestorPropertyContainerName_Template,
        this->toCodeGenVarName(pString).data(),
        nullptr);
}

std::wstring CGenerateFastCppTemplate::getMethodCallback(
    const schema::CMethodInfo*pMethodInfo,
    std::wstring& invokeInstance)
{
    invokeInstance = L"this";
    std::wstring methodNameCallback = pMethodInfo->getName();
    if (pMethodInfo->getIsAsync() && !foundation::library::string_util::ends_with(methodNameCallback, _AsyncPostFix))
    {
        methodNameCallback += _AsyncPostFix;
    }
    else if (_generateMethodInternal)
    {
        methodNameCallback += _InternalPostFix;
    }
    return methodNameCallback;
}

void CGenerateFastCppTemplate::emitWrapperMethod(
    std::wostream& os,
    const schema::CMethodInfo*pMethodInfo)
{
    os << "\t// Method:" << pMethodInfo->getName() << std::endl;
    // Emit Wrapper access
    os << "\tHRESULT " << pMethodInfo->getName() << "(";

    bool isAsync = pMethodInfo->getIsAsync();

    std::wostringstream osLocalVars;
    std::wostringstream osLambdaParameters;

    int parameterIndex = 1;
    for (schema::_MethodParamIteratorType::const_iterator iterParam = pMethodInfo->getParameters().begin();
        iterParam != pMethodInfo->getParameters().end();
        ++iterParam)
    {
        bool isArrayParameter = ((*iterParam)->getPropertyType() & 0x400) != 0;

        if (iterParam != pMethodInfo->getParameters().begin())
        {
            os << ",";
        }
        emitDeclarePropertyTypeInfo(os, (*iterParam), false, parameterIndex);
        os << " " << (*iterParam)->getParameterName();

        if (parameterIndex > 1)
        {
            osLambdaParameters << ",";
        }

        if (isAsync)
        {
            if (isArrayParameter)
            {
                osLocalVars << "\t\t";
                emitDeclareArrayWrapperType(osLocalVars, *iterParam);
                osLocalVars << " " << (*iterParam)->getParameterName() << "_array("
                    << "size_" << parameterIndex << "," << (*iterParam)->getParameterName() << ");" << std::endl;

                osLambdaParameters << "size_" << parameterIndex << ",";
                osLambdaParameters << (*iterParam)->getParameterName() << "_array.GetRawBuffer()";
            }
            else if ((*iterParam)->getPropertyType() == foundation::PropertyType_String)
            {
                osLocalVars << "\t\tfoundation::HStringPtr "
                    << (*iterParam)->getParameterName() << "_ptr("
                    << (*iterParam)->getParameterName() << ");" << std::endl;
                osLambdaParameters << (*iterParam)->getParameterName() << "_ptr";
            }
            else if ((*iterParam)->getPropertyType() == foundation::PropertyType_Inspectable)
            {
                osLocalVars << "\t\tfoundation::";
                if ((*iterParam)->getModelType() != nullptr)
                {
                    osLocalVars << "ComPtr<";
                    emitFullName(osLocalVars, (*iterParam)->getModelType());
                    osLocalVars << ">";
                }
                else
                {
                    osLocalVars << "InspectablePtr";
                }
                osLocalVars << " "
                    << (*iterParam)->getParameterName()
                    << "_ptr("
                    << (*iterParam)->getParameterName()
                    << ");"
                    << std::endl;
                osLambdaParameters << (*iterParam)->getParameterName() << "_ptr";
            }
            else
            {
                osLambdaParameters << (*iterParam)->getParameterName();
            }
        }
        else
        {
            if (isArrayParameter)
            {
                osLambdaParameters << "size_" << parameterIndex << ",";
            }
            osLambdaParameters << (*iterParam)->getParameterName();
        }

        ++parameterIndex;
    }
    bool hasResult = pMethodInfo->getResultType() && pMethodInfo->getResultType()->getPropertyType() != foundation::PropertyType_Empty;
    if (hasResult || isAsync)
    {
        if (pMethodInfo->getParameters().size())
        {
            osLambdaParameters << ",";
            os << ",";
        }
        emitWrapperResultTypeInfo(
            os,
            pMethodInfo->getResultType(),
            isAsync);
        os << (isAsync ? " *" :" ");
        os << "pResult";
        if (!isAsync)
        {
            if (isPropertyTypeInfoArray(pMethodInfo->getResultType()))
            {
                osLambdaParameters << "size,";
            }
            osLambdaParameters << "pResult";
        }
    }
    os << ")" << std::endl;

    if (isAsync)
    {

        os << FormatW(_methodInvokeAsyncFastModel_Template,
            pMethodInfo->getName().data(),
            osLocalVars.str().data(),
            osLambdaParameters.str().data(),
            _useAsyncOperationClassPtr ? L"" : L".GetClassInterface()",
            foundation::library::string_util::ends_with(pMethodInfo->getName(),_AsyncPostFix) ? _InternalPostFix: _AsyncPostFix,
            nullptr);
    }
    else
    {
        os << FormatW(_methodInvokSyncFastModel_Template,
            pMethodInfo->getName().data(),
            osLambdaParameters.str().data(),
            nullptr);
    }
}

void CGenerateFastCppTemplate::emitDelegateTypeVarAddress(
    std::wostream& os,
    const schema::CPropertyTypeInfo*pPropertyTypeInfo,
    const wchar_t *pVarName)
{
    if (
        !isPropertyTypeInfoArray(pPropertyTypeInfo)
        &&
        (
            (pPropertyTypeInfo->getPropertyType() == foundation::PropertyType_String) || 
            isUseWrapperDelegatePropertyTypeInfo(pPropertyTypeInfo)
        ))
    {
        os << pVarName << ".GetAddressOf()";
    }
    else
    {
        emitTypeVarAddress(os, pPropertyTypeInfo, pVarName);
    }
}


void CGenerateFastCppTemplate::emitInternalGetBodyMethods(	
    std::wostream& osInternalAccess,
    const schema::CPropertyInfo*pPropertyInfo)
{
    const schema::CTypeInfo *pModelTypeInfo = pPropertyInfo->getModelType();
    
    schema::ModelTypeInfoType modelType = pModelTypeInfo ?
        pModelTypeInfo->getModelType() : schema::ModelTypeInfoType_None;

    if (pPropertyInfo->getFlags() & PropertyFlagType_IsWeakReference)
    {       
       osInternalAccess << "\t\treturn " << toContainerPropertyName(pPropertyInfo->getName().c_str()) << ".ResolveReference(*pValue);" << std::endl;        
    }
    else if (pPropertyInfo->isParent())
    {
        osInternalAccess << FormatW(_fastModelParentPropertyGet_Template,
            toTypeInfoName(pPropertyInfo->getParent().getName().c_str()).data(),
            pPropertyInfo->getName().data(),
            nullptr) << std::endl;
    }
    else if(pPropertyInfo->getPropertyType() & 0x400)
    {
        if (modelType != schema::ModelTypeInfoType_None && modelType != schema::ModelTypeInfoType_Enum)
        {
            //<< typeInfoNamespace << "::" << pModelTypeInfo->getName().c_str() <<
            std::wstring typeInfoNamespace = this->getNamespaceLookup(pModelTypeInfo->getParent().getNamespace());
            osInternalAccess << "\t\t" << toContainerPropertyName(pPropertyInfo->getName().c_str()) << ".CopyTo(size," << "pValue);" << std::endl;
        }
        else
        {
            osInternalAccess << "\t\t" << toContainerPropertyName(pPropertyInfo->getName().c_str()) << ".CopyTo(size,pValue);" << std::endl;
        }
        osInternalAccess << "\t\treturn S_OK;" << std::endl;
    }
    else if ((modelType == schema::ModelTypeInfoType_None || modelType == schema::ModelTypeInfoType_Enum) &&
        pPropertyInfo->getPropertyType() != foundation::PropertyType_String &&
        pPropertyInfo->getPropertyType() != foundation::PropertyType_Inspectable)
    {
        osInternalAccess << "\t\t*pValue = " << toContainerPropertyName(pPropertyInfo->getName().c_str()) << ";" << std::endl;
        osInternalAccess << "\t\treturn S_OK;" << std::endl;
    }
    else
    {
        osInternalAccess << "\t\treturn " << toContainerPropertyName(pPropertyInfo->getName().c_str()) << ".CopyTo(pValue);" << std::endl;
    }
}


void CGenerateFastCppTemplate::emitPropertyAccessMethods(
    std::wostream& osPublicAccess,
    std::wostream& osInternalAccess,
    std::wostream& osPrivateAccess,
    std::wostream& osPrivateAccessDeclare,
    const schema::CPropertyInfo*pPropertyInfo)
{
    std::wstring typeInfoName = toTypeInfoName(pPropertyInfo->getParent().getName());

    std::wstring typeInfoNameCodeGen = this->toCodeGenTypeName(typeInfoName);

    std::wstring propertyNameCodeGen = this->toCodeGenTypeName(pPropertyInfo->getName());
    std::wstring propertyNameMemberCodeGen = this->toCodeGenVarName(pPropertyInfo->getName());

    bool isPropertyArray = (pPropertyInfo->getPropertyType() & 0x400) != 0;
    bool isAncestor = (pPropertyInfo->getFlags() & PropertyFlagType_IsAncestor) != 0;
    bool isWeakRef = (pPropertyInfo->getFlags() & PropertyFlagType_IsWeakReference) != 0;
    bool isEnum = (pPropertyInfo->getFlags() & PropertyFlagType_IsEnum) != 0;

    osPublicAccess << "\t// Property:" << pPropertyInfo->getName() << std::endl;

    // Emit public Get method
    osPublicAccess << "\tHRESULT " << "Get" << pPropertyInfo->getName() << "(";
    emitDeclarePropertyTypeInfo(osPublicAccess, pPropertyInfo, true);
    osPublicAccess << " pValue) override" << std::endl;
    osPublicAccess << "\t{" << std::endl;
    if (isAncestor)
    {
        osPublicAccess << FormatW(_fastModelAncestorPropertyGet_Template,
            toTypeInfoName(pPropertyInfo->getParent().getName().c_str()).data(),
            pPropertyInfo->getName().data(),
            nullptr) << std::endl;
    }
    else
    {

        osPublicAccess << "\t\treturn this->GetPropertyInternal("
            << typeInfoName << "::Property_" << pPropertyInfo->getName() << ",[=] {" << std::endl
            << "\t\t\tfoundation::library::FoundationCriticalSection cs(this->GetCriticalSection());" << std::endl;

        if (pPropertyInfo->isRuntimeActivated())
        {
            osPublicAccess << FormatW(_fastModelEnsureActivationCall_Template,propertyNameCodeGen.data(), nullptr);
        }
        else
        {
            osPublicAccess << "\t\t\treturn this->Get" << propertyNameCodeGen << "Internal(" << (isPropertyArray ? "size ," : "") << "pValue);" << std::endl;
        }
        osPublicAccess << "\t\t});" << std::endl;

    }
    osPublicAccess << "\t}" << std::endl;

    bool canWriteProperty = (pPropertyInfo->getFlags() & PropertyFlagType_CanWrite) != 0;
    // emit set property access (public or private depending on schema flags)
    if (!isAncestor)
    {
        std::wostream& osSetProperty = canWriteProperty ? osPublicAccess : osPrivateAccess;

        bool isArray = isPropertyTypeInfoArray(pPropertyInfo);

        // Emit public set method
        osSetProperty << "\tHRESULT " << "Set" << pPropertyInfo->getName() << "(";
        emitDeclarePropertyTypeInfo(osSetProperty, pPropertyInfo, false);
        osSetProperty << " value) override" << std::endl;
        osSetProperty << "\t{" << std::endl;

        osSetProperty << "\t\treturn this->Set" << (isEnum && !isArray ? "Enum" : "") << "PropertyInternal("
            << typeInfoName
            << "::Property_"
            << pPropertyInfo->getName()
            << (isPropertyArray ? ", size" : "")
            << ", ";
        if (isEnum && !isArray) {
            osSetProperty << FormatW(L"{0}::{1}::TypeId,", 
                this->getNamespaceLookup(pPropertyInfo->getModelType()).c_str(),
                toTypeInfoName((const schema::CEnumTypeInfo *)pPropertyInfo->getModelType()).c_str(), nullptr);
        }
        osSetProperty << "value); " << std::endl;
        osSetProperty << "\t}" << std::endl;
    }

    
    // generate private access only if the property is write only
    if ((pPropertyInfo->getFlags() & PropertyFlagType_CanRead) == 0)
    {
        // Emit set internal interface declare
        osPrivateAccessDeclare << "\tvirtual HRESULT " << "Get" << pPropertyInfo->getName() << "(";
        emitDeclarePropertyTypeInfo(osPrivateAccessDeclare, pPropertyInfo, true);
        osPrivateAccessDeclare << " value) = 0;" << std::endl;
    }

    // Simple getters and setters
    std::wostringstream typeDeclare;
    emitModelTypeVarDeclare(typeDeclare, pPropertyInfo, L"value");

    std::wostringstream returnTypeDeclare;
    emitWrapperPropertyTypeInfo(returnTypeDeclare, pPropertyInfo);

    // emit simple getter
    if (isAncestor || pPropertyInfo->isParent())
    {   
        osPublicAccess << FormatW(_fastModelGetAncestorTypeDirectly_Template,
            returnTypeDeclare.str().data(),            
            pPropertyInfo->getName().data(),
            typeDeclare.str().data(),
            nullptr) << std::endl;
    }
    else if (isWeakRef)
    {
        osPublicAccess << FormatW(_fastModelGetWeakPropertyRef_Template,
            returnTypeDeclare.str().data(),
            pPropertyInfo->getName().data(),
            typeDeclare.str().data(),
            propertyNameCodeGen.data(),
            nullptr) << std::endl;
    }
    else if (!pPropertyInfo->isCustomContainer())
    {
        std::wostringstream typeDeclareArray;
        if (isPropertyArray)
        {            
            typeDeclareArray << "const ";
            emitArrayWrapperType(typeDeclareArray, pPropertyInfo, L"", true);
        }

        // make simple types getter methods be const.
        std::wstring methodConst;
        if (!pPropertyInfo->getModelType() || pPropertyInfo->getModelType()->getModelType() == schema::ModelTypeInfoType_Enum)
        {
            methodConst = L"const";
        }
        
        osPublicAccess << FormatW(_fastModelGetArrayWrapperRef_Template,
            isPropertyArray ? typeDeclareArray.str().data() : returnTypeDeclare.str().data(),
            pPropertyInfo->getName().data(),
            toContainerPropertyName(pPropertyInfo->getName().c_str()).data(), 
            methodConst.data(),
            nullptr) << std::endl;
    }

    // exit if its ancestor we dont need internal setters.
    if (isAncestor)
    {
        return;
    }

    // Emit internal get method
    osInternalAccess << "\tvirtual HRESULT " << "Get" << propertyNameCodeGen << "Internal(";
    emitDeclarePropertyTypeInfo(osInternalAccess, pPropertyInfo, true);
    osInternalAccess << " pValue)" << std::endl;
    osInternalAccess << "\t{" << std::endl;
    if (pPropertyInfo->isCustomContainer())
    {
        osInternalAccess << "\t\tfoundation_assert(false);" << std::endl;
        osInternalAccess << "\t\treturn S_OK;\n" << std::endl;
    }
    else if (pPropertyInfo->getModelType() && pPropertyInfo->getModelType()->getModelType() == schema::ModelTypeInfoType_Command)
    {
        osInternalAccess << "\t\treturn foundation::QueryInterfaceIf(_" << propertyNameMemberCodeGen << "Value";
        if (pPropertyInfo->isAutoGenerate())
        {
            // it is a class command
            osInternalAccess << "->CastToUnknown()";
        }
        osInternalAccess << ", pValue); " << std::endl;
    }	
    else
    {
        emitInternalGetBodyMethods(osInternalAccess, pPropertyInfo);
    }
    osInternalAccess << "\t}" << std::endl;

    if (!pPropertyInfo->isParent())
    {		
        // Emit internal set method
        osInternalAccess << "\tvirtual HRESULT " << "Set" << propertyNameCodeGen << "Internal(";
        emitDeclarePropertyTypeInfo(osInternalAccess, pPropertyInfo, false);
        osInternalAccess << " value)" << std::endl;
        osInternalAccess << "\t{" << std::endl;
        if (pPropertyInfo->getFlags() & PropertyFlagType_IsWeakReference)
        {
            osInternalAccess <<"\t\treturn "<< toContainerPropertyName(pPropertyInfo->getName().c_str()) << ".Attach(value);" << std::endl;
        }
        else if (pPropertyInfo->isCustomContainer())
        {
            osInternalAccess << "\t\tfoundation_assert(false);" << std::endl;
            osInternalAccess << "\t\treturn S_OK;" << std::endl;
        }
        else if (pPropertyInfo->getModelType() && pPropertyInfo->getModelType()->getModelType() == schema::ModelTypeInfoType_Command)
        {
            //TODO:: do nothing for now...
            osInternalAccess << "\t\treturn S_OK;" << std::endl;
        }
        else if (isPropertyArray)
        {
            std::wstring containerPropertyName = toContainerPropertyName(pPropertyInfo->getName().c_str());
            if (isPropertyTypeInfoEnum(pPropertyInfo))
            {
                osInternalAccess << "\t\t" << containerPropertyName << ".CopyFrom(size,value);" << std::endl;
                osInternalAccess << "\t\t" << "return S_OK;" << std::endl;
            }
            else
            {
                osInternalAccess << FormatW(_fastModelSetInternalArraySupport,
                    containerPropertyName.data(),
                    nullptr) << std::endl;
            }
        }
        else
        {
            osInternalAccess << "\t\t" << toContainerPropertyName(pPropertyInfo->getName().c_str()) << " = " << "value;" << std::endl;
            osInternalAccess << "\t\treturn S_OK;" << std::endl;
        }
        
        osInternalAccess << "\t}" << std::endl;
    }

    // generate private access only if the property is read only
    if ((pPropertyInfo->getFlags() & PropertyFlagType_CanWrite) == 0)
    {
        // Emit set internal interface declare
        osPrivateAccessDeclare << "\tvirtual HRESULT " << "Set" << pPropertyInfo->getName() << "(";
        emitDeclarePropertyTypeInfo(osPrivateAccessDeclare, pPropertyInfo, false);
        osPrivateAccessDeclare << " value) = 0;" << std::endl;
    }
}

void CGenerateFastCppTemplate::emitPropertyCommandHandler(
    std::wostream& osAbstractMethods,
    const schema::CPropertyInfo*pPropertyInfo)
{
    assert(pPropertyInfo->getModelType());
    assert(pPropertyInfo->getModelType()->getModelType() == schema::ModelTypeInfoType_Command);

    const schema::CCommandTypeInfo *pCommandModelInfo = (const schema::CCommandTypeInfo *)pPropertyInfo->getModelType();
    assert(pCommandModelInfo);

    bool hasParameter = pCommandModelInfo->getParameterTypeInfo() &&
        pCommandModelInfo->getParameterTypeInfo()->getPropertyType() != foundation::PropertyType_Empty;
    bool hasResult = pCommandModelInfo->getResultTypeInfo() &&
        pCommandModelInfo->getResultTypeInfo()->getPropertyType() != foundation::PropertyType_Empty;

    std::wostringstream osExecuteAbstractMethod;

    std::wstring commandNameCallback = pPropertyInfo->getName();
    if (pCommandModelInfo->getIsAsync())
    {
        commandNameCallback += L"Async";
    }

    osExecuteAbstractMethod << "\tvirtual HRESULT Execute" << commandNameCallback << "(";

	std::wostringstream osParameterDeclare;
    if (hasParameter)
    {
        emitModelPropertyTypeInfo(osExecuteAbstractMethod, pCommandModelInfo->getParameterTypeInfo(), false);
        osExecuteAbstractMethod << " parameter";
    }

    if ((hasResult || pCommandModelInfo->getIsAsync()) && hasParameter)
    {
        osExecuteAbstractMethod << ", ";
    }

    if (pCommandModelInfo->getIsAsync())
    {
        emitAsyncOperationClassDeclare(osExecuteAbstractMethod);
    }
    else if (hasResult)
    {
        emitModelPropertyTypeInfo(osExecuteAbstractMethod, pCommandModelInfo->getResultTypeInfo(), true);
        if (isUseWrapperDelegatePropertyTypeInfo(pCommandModelInfo->getResultTypeInfo()))
        {
            osExecuteAbstractMethod << " result";
        }
        else
        {
            osExecuteAbstractMethod << " pResult";
        }
    }

    osExecuteAbstractMethod << ")" << std::endl << "\
\t{\n\
\t\tfoundation_assert(false);\n\
\t\treturn E_NOTIMPL;\n\
\t}" << std::endl; 

    osAbstractMethods << osExecuteAbstractMethod.str();

	if (pCommandModelInfo->getIsUnknownState())
    {
		std::wostringstream osCanExecuteAbstractMethod;
		osCanExecuteAbstractMethod << "\tvirtual HRESULT CanExecute" << commandNameCallback << "(";
		if (hasParameter)
		{
            emitModelPropertyTypeInfo(osCanExecuteAbstractMethod, pCommandModelInfo->getParameterTypeInfo(), false);
			osCanExecuteAbstractMethod << " parameter, ";
		}
		osCanExecuteAbstractMethod << "bool* pValue)\n\
\t{\n\
\t\tUNREFERENCED_PARAMETER(pValue);\n\
\t\tfoundation_assert(false);\n\
\t\treturn E_NOTIMPL;\n\
\t}" << std::endl;

        osAbstractMethods << osCanExecuteAbstractMethod.str();
    }
}

std::wstring CGenerateFastCppTemplate::toIdlIIDType(GUID iidType)
{
    return ToWideString(iidType);
}

std::wstring CGenerateFastCppTemplate::toIdlIIDType(const schema::CTypeInfo*pModelTypeInfo)
{
    return toIdlIIDType(createUniqueIId(pModelTypeInfo));
}

IID CGenerateFastCppTemplate::createUniqueIId(const schema::CTypeInfo*pModelTypeInfo, std::wstring postFix)
{
    std::wstring fullName =
        L"fastmodel" +
        pModelTypeInfo->getParent().getNamespace() +
        L"." +
        pModelTypeInfo->getName() +
        postFix;
    IID iid = CreateIIDTypeFromString(fullName.c_str());
    return iid;
}

void CGenerateFastCppTemplate::emitReturnResult(
    std::wostream& os,
    const schema::CPropertyTypeInfo*pResultPropertyTypeInfo,
    bool isAsync)
{
    assert(pResultPropertyTypeInfo);

    os << "\t\tif(SUCCEEDED(hr))" << std::endl;
    os << "\t\t{" << std::endl;

    bool isResultArray = (pResultPropertyTypeInfo->getPropertyType() & 0x400) != 0;

    if (isAsync
        ||
        pResultPropertyTypeInfo->getPropertyType() == foundation::PropertyType_Inspectable)
    {
        os << FormatW(_returFastnModelType_Template, nullptr);
    }
    else
    {
        os << "\t\t\thr = " << getCoreNamespace() << "::pv_util::GetValue(result,";
        if (isResultArray)
        {
            os << "size,";
        }
        os << "pResult);" << std::endl;
    }
    os << "\t\t}" << std::endl;
}


void CGenerateFastCppTemplate::emitWrapperResultTypeInfo(
    std::wostream& os,
    const schema::CPropertyTypeInfo*pPropertyTypeInfo,
    bool isAsync)
{
    if (isAsync)
    {        
        os << toPropertyTypeInfoAsync(pPropertyTypeInfo, true) << "*";        
    }
    else
    {
        emitDeclarePropertyTypeInfo(os, pPropertyTypeInfo, true);
    }
}

void CGenerateFastCppTemplate::emitAncestorContainerFriendDecl(
    std::wostream& os,
    const schema::CObservableObjectInfo *pModelType)
{
    schema::CTypeInfo *parent = (schema::CTypeInfo*)pModelType->getBaseType();

    while (parent != nullptr)
    {
        os << FormatW(_fastModelBaseContainerFriend_Template, this->toCodeGenTypeName(toTypeInfoName(parent->getName().c_str())).data(), nullptr) <<std::endl;
        parent = (schema::CTypeInfo*)parent->getBaseType();
    }
}

void CGenerateFastCppTemplate::emitContainerReleaseStatement(
	std::wostream& os,
	const schema::CPropertyInfo* pPropertyInfo)
{
	if ((pPropertyInfo->getFlags() & PropertyFlagType_IsWeakReference) != 0)
	{
		return;
	}

    bool isStringOrArrayProp = isPropertyTypeInfoArray(pPropertyInfo);

    const schema::CTypeInfo* pModelTypeInfo = pPropertyInfo->getModelType();
    if (pModelTypeInfo != nullptr)
    {
        switch (pModelTypeInfo->getModelType())
        {
            case schema::ModelTypeInfoType_None:
            case schema::ModelTypeInfoType_Enum:
                return;
        }
    }
    else
    {
        switch (pPropertyInfo->getPropertyType())
        {
            case foundation::PropertyType_String:
                isStringOrArrayProp = true;
            case foundation::PropertyType_Inspectable:
                break;
            default:
                return;
        }
    }

    os << "\n\t\t" << toContainerPropertyName(pPropertyInfo->getName().c_str()) << (isStringOrArrayProp ? L".Clear();" : L".Release();");
}
